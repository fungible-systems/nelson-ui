import { t as transformCss, d as dudupeAndJoinClassList } from './transformCss-82016dac.browser.esm.js';
import { setAdapterIfNotSet, getIdentOption, appendCss, registerClassName, registerComposition, markCompositionUsed } from '../adapter/dist/vanilla-extract-css-adapter.browser.esm.js';
import hash from '@emotion/hash';
import { getAndIncrementRefCounter, getFileScope, hasFileScope } from '../fileScope/dist/vanilla-extract-css-fileScope.browser.esm.js';
import { walkObject, get } from '@vanilla-extract/private';
import cssesc from 'cssesc';
import { diff } from 'deep-object-diff';
import chalk from 'chalk';
import dedent from 'dedent';
import deepmerge from 'deepmerge';
import 'css-what';

const stylesheets = {};
const localClassNames = new Set();
const composedClassLists = [];
let bufferedCSSObjs = [];

function getStylesheet({
  packageName,
  filePath
}) {
  const fileScopeId = packageName ? `${packageName}${filePath}` : filePath;

  if (stylesheets[fileScopeId]) {
    return stylesheets[fileScopeId];
  }

  const styleEl = document.createElement('style');
  document.head.appendChild(styleEl);

  if (!styleEl.sheet) {
    throw new Error(`Couldn't create stylesheet`);
  }

  stylesheets[fileScopeId] = styleEl.sheet;
  return styleEl.sheet;
}

const browserRuntimeAdapter = {
  appendCss: cssObj => {
    bufferedCSSObjs.push(cssObj);
  },
  registerClassName: className => {
    localClassNames.add(className);
  },
  registerComposition: composition => {
    composedClassLists.push(composition);
  },
  markCompositionUsed: () => {},
  onEndFileScope: fileScope => {
    const css = transformCss({
      localClassNames: Array.from(localClassNames),
      composedClassLists,
      cssObjs: bufferedCSSObjs
    });
    const stylesheet = getStylesheet(fileScope);
    const existingRuleCount = stylesheet.cssRules.length;
    let ruleIndex = 0;

    for (const rule of css) {
      try {
        if (ruleIndex < existingRuleCount) {
          stylesheet.deleteRule(ruleIndex);
        }

        stylesheet.insertRule(rule, ruleIndex++);
      } catch (e) {
        console.warn(`Failed to insert rule\n${rule}`); // insert placeholder rule to keep index count correct

        stylesheet.insertRule('.--placeholder-rule--{}', ruleIndex - 1);
      }
    } // Delete remaining rules


    while (ruleIndex < existingRuleCount) {
      stylesheet.deleteRule(ruleIndex++);
    }

    bufferedCSSObjs = [];
  },
  getIdentOption: () => process.env.NODE_ENV === 'production' ? 'short' : 'debug'
};

{
  setAdapterIfNotSet(browserRuntimeAdapter);
}

function getDevPrefix(debugId) {
  const parts = debugId ? [debugId] : [];
  const {
    filePath
  } = getFileScope();
  const matches = filePath.match(/(?<dir>[^\/\\]*)?[\/\\]?(?<file>[^\/\\]*)\.css\.(ts|js|tsx|jsx)$/);

  if (matches && matches.groups) {
    const {
      dir,
      file
    } = matches.groups;
    parts.unshift(file && file !== 'index' ? file : dir);
  }

  return parts.join('_');
}

function generateIdentifier(debugId) {
  // Convert ref count to base 36 for optimal hash lengths
  const refCount = getAndIncrementRefCounter().toString(36);
  const {
    filePath,
    packageName
  } = getFileScope();
  const fileScopeHash = hash(packageName ? `${packageName}${filePath}` : filePath);
  let identifier = `${fileScopeHash}${refCount}`;

  if (getIdentOption() === 'debug') {
    const devPrefix = getDevPrefix(debugId);

    if (devPrefix) {
      identifier = `${devPrefix}__${identifier}`;
    }
  }

  return identifier.match(/^[0-9]/) ? `_${identifier}` : identifier;
}

const normaliseObject = obj => walkObject(obj, () => '');

function validateContract(contract, tokens) {
  const theDiff = diff(normaliseObject(contract), normaliseObject(tokens));
  const valid = Object.keys(theDiff).length === 0;
  return {
    valid,
    diffString: valid ? '' : renderDiff(contract, theDiff)
  };
}

function diffLine(value, nesting, type) {
  const whitespace = [...Array(nesting).keys()].map(() => '  ').join('');
  const line = `${type ? type : ' '}${whitespace}${value}`;

  if (process.env.NODE_ENV !== 'test') {
    if (type === '-') {
      return chalk.red(line);
    }

    if (type === '+') {
      return chalk.green(line);
    }
  }

  return line;
}

function renderDiff(orig, diff, nesting = 0) {
  const lines = [];

  if (nesting === 0) {
    lines.push(diffLine('{', 0));
  }

  const innerNesting = nesting + 1;
  const keys = Object.keys(diff).sort();

  for (const key of keys) {
    const value = diff[key];

    if (!(key in orig)) {
      lines.push(diffLine(`${key}: ...,`, innerNesting, '+'));
    } else if (typeof value === 'object') {
      lines.push(diffLine(`${key}: {`, innerNesting));
      lines.push(renderDiff(orig[key], diff[key], innerNesting));
      lines.push(diffLine('}', innerNesting));
    } else {
      lines.push(diffLine(`${key}: ...,`, innerNesting, '-'));
    }
  }

  if (nesting === 0) {
    lines.push(diffLine('}', 0));
  }

  return lines.join('\n');
}

function createVar(debugId) {
  // Convert ref count to base 36 for optimal hash lengths
  const refCount = getAndIncrementRefCounter().toString(36);
  const {
    filePath,
    packageName
  } = getFileScope();
  const fileScopeHash = hash(packageName ? `${packageName}${filePath}` : filePath);
  const varName = getIdentOption() === 'debug' && debugId ? `${debugId}__${fileScopeHash}${refCount}` : `${fileScopeHash}${refCount}`;
  const cssVarName = cssesc(varName.match(/^[0-9]/) ? `_${varName}` : varName, {
    isIdentifier: true
  });
  return `var(--${cssVarName})`;
}
function fallbackVar(...values) {
  let finalValue = '';
  values.reverse().forEach(value => {
    if (finalValue === '') {
      finalValue = String(value);
    } else {
      if (typeof value !== 'string' || !/^var\(--.*\)$/.test(value)) {
        throw new Error(`Invalid variable name: ${value}`);
      }

      finalValue = value.replace(/\)$/, `, ${finalValue})`);
    }
  });
  return finalValue;
}
function assignVars(varContract, tokens) {
  const varSetters = {};
  const {
    valid,
    diffString
  } = validateContract(varContract, tokens);

  if (!valid) {
    throw new Error(`Tokens don't match contract.\n${diffString}`);
  }

  walkObject(tokens, (value, path) => {
    varSetters[get(varContract, path)] = String(value);
  });
  return varSetters;
}
function createThemeContract(tokens) {
  return walkObject(tokens, (_value, path) => {
    return createVar(path.join('-'));
  });
}
function createGlobalThemeContract(tokens, mapFn) {
  return walkObject(tokens, (value, path) => {
    const rawVarName = typeof mapFn === 'function' ? mapFn(value, path) : value;
    const varName = typeof rawVarName === 'string' ? rawVarName.replace(/^\-\-/, '') : null;

    if (typeof varName !== 'string' || varName !== cssesc(varName, {
      isIdentifier: true
    })) {
      throw new Error(`Invalid variable name for "${path.join('.')}": ${varName}`);
    }

    return `var(--${varName})`;
  });
}

function createGlobalTheme(selector, arg2, arg3) {
  const shouldCreateVars = Boolean(!arg3);
  const themeVars = shouldCreateVars ? createThemeContract(arg2) : arg2;
  const tokens = shouldCreateVars ? arg2 : arg3;
  appendCss({
    type: 'global',
    selector: selector,
    rule: {
      vars: assignVars(themeVars, tokens)
    }
  }, getFileScope());

  if (shouldCreateVars) {
    return themeVars;
  }
}
function createTheme(arg1, arg2, arg3) {
  const themeClassName = generateIdentifier(typeof arg2 === 'object' ? arg3 : arg2);
  registerClassName(themeClassName);
  const vars = typeof arg2 === 'object' ? createGlobalTheme(themeClassName, arg1, arg2) : createGlobalTheme(themeClassName, arg1);
  return vars ? [themeClassName, vars] : themeClassName;
}

function composedStyle(rules, debugId) {
  const className = generateIdentifier(debugId);
  registerClassName(className);
  const classList = [];
  const styleRules = [];

  for (const rule of rules) {
    if (typeof rule === 'string') {
      classList.push(rule);
    } else {
      styleRules.push(rule);
    }
  }

  let result = className;

  if (classList.length > 0) {
    result = `${className} ${dudupeAndJoinClassList(classList)}`;
    registerComposition({
      identifier: className,
      classList: result
    });

    if (styleRules.length > 0) {
      // If there are styles attached to this composition then it is
      // always used and should never be removed
      markCompositionUsed(className);
    }
  }

  if (styleRules.length > 0) {
    const rule = deepmerge.all(styleRules, {
      // Replace arrays rather than merging
      arrayMerge: (_, sourceArray) => sourceArray
    });
    appendCss({
      type: 'local',
      selector: className,
      rule
    }, getFileScope());
  }

  return result;
}

function style(rule, debugId) {
  if (Array.isArray(rule)) {
    return composedStyle(rule, debugId);
  }

  const className = generateIdentifier(debugId);
  registerClassName(className);
  appendCss({
    type: 'local',
    selector: className,
    rule
  }, getFileScope());
  return className;
}
/**
 * @deprecated The same functionality is now provided by the 'style' function when you pass it an array
 */

function composeStyles(...classNames) {
  const compose = hasFileScope() ? composedStyle : dudupeAndJoinClassList;
  return compose(classNames);
}
function globalStyle(selector, rule) {
  appendCss({
    type: 'global',
    selector,
    rule
  }, getFileScope());
}
function fontFace(rule, debugId) {
  const fontFamily = `"${cssesc(generateIdentifier(debugId), {
    quotes: 'double'
  })}"`;

  if ('fontFamily' in rule) {
    throw new Error(dedent`
          This function creates and returns a hashed font-family name, so the "fontFamily" property should not be provided.
  
          If you'd like to define a globally scoped custom font, you can use the "globalFontFace" function instead.
        `);
  }

  appendCss({
    type: 'fontFace',
    rule: { ...rule,
      fontFamily
    }
  }, getFileScope());
  return fontFamily;
}
function globalFontFace(fontFamily, rule) {
  appendCss({
    type: 'fontFace',
    rule: { ...rule,
      fontFamily
    }
  }, getFileScope());
}
function keyframes(rule, debugId) {
  const name = cssesc(generateIdentifier(debugId), {
    isIdentifier: true
  });
  appendCss({
    type: 'keyframes',
    name,
    rule
  }, getFileScope());
  return name;
}
function globalKeyframes(name, rule) {
  appendCss({
    type: 'keyframes',
    name,
    rule
  }, getFileScope());
}
function styleVariants(...args) {
  if (typeof args[1] === 'function') {
    const data = args[0];
    const mapData = args[1];
    const debugId = args[2];
    const classMap = {};

    for (const key in data) {
      classMap[key] = style(mapData(data[key], key), debugId ? `${debugId}_${key}` : key);
    }

    return classMap;
  }

  const styleMap = args[0];
  const debugId = args[1];
  const classMap = {};

  for (const key in styleMap) {
    classMap[key] = style(styleMap[key], debugId ? `${debugId}_${key}` : key);
  }

  return classMap;
}

export { assignVars, composeStyles, createGlobalTheme, createGlobalThemeContract, createTheme, createThemeContract, createVar, fallbackVar, fontFace, generateIdentifier, globalFontFace, globalKeyframes, globalStyle, keyframes, style, styleVariants };
